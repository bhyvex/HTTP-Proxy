TODO
----

Here are all the features I plan to add to HTTP::Proxy, in the form of a
roadmap.

Things are listed by big features, since I seem to be unable to follow
my own roadmaps. :-/

* Windows support
 - It seems that having the parent process listen and the child processes
   accept() on the socket only work correctly under linux
 - I'll have to change the way client connections are accepted in the
   next version

* Proxy Control
 - Control the proxy via specific URIs
 - Commands are called asking for http://proxy/cmd
   (the host part of the URI should be configurable)
   where cmd is a key to a dispatch table
 - Example commands
   * status => return some debug information
   * config => live config management (uses forms)
   * should be able to add more in inheriting classes
     => as an example, we could rewrite RGS's biscuit script
 - all this requires CGI/HTML, which I don't want to write or maintain
   the program should automatically create the configuration forms
   and handle the HTML/CSS stuff
 - configuration commands are handled by the parent process, so that
   future forked process obey the new configuration
 - how do subclassed HTTP::Proxy modules handle this?
 - can someone add his own commands by modifying either the class or
   the instance dispatch table?
 - the parent process preforks children, when a control URL is requested
   the child can write data to a special file/pipe and kill HUP the
   parent so that it reads the new information
 => control system probably means having a HTTP::Proxy::Control module...

* Filters
 - filters cause several problems: the biggest being that, if they
   change the data size, they should update the Content-Lenght header
 - the filters to apply to a specific request or response can be
   determined from the headers, there is no need to go through the
   whole list of filters each time.
 - unfiltered response body should be send on the fly, while response
   that are to be filtered should be held in custody until fully
   received and modified. Once the whole response is ready, the
   filter can update the Content-Length: header.
 - Must support the Content-Encoding: gzip headers
 - Accept-Encoding: content-coding tokens are identity, gzip, compress, deflate
   

* On the fly forwarding
 - handle big responses (>1Mb) with the LWP::UA callback system
   => short responses are concatenated together in a simple scalar,
      that gets filtered at the end
   => longer responses are filtered on the fly and sent as-is to the
      client. Since only chunks of the response are filtered, this can
      result in badly filtered data (I don't think we can do anything
      about it...)
 - this works, but we *have* a problem with Content-Length:
 - I suppose there is a problem also with gzip Transfered files, if
   we forward them as is, we can't filter them (need to think more
   about that)

* record sessions
 - the logs are not enough
 - we want to be able to completely store a browsing session, probably
   as a tree, for example to use them as a base for WWW::Mechanize::Builder

* https and CONNECT support
 - proxy a https site, so as to filter and record, just as we do for
   http requests.
 - specifi URLs ?
   => example: http://proxy/https://www.secure.com:443/index.html
   => This kind of stuff requires some content rewriting...

* support keep-alive with the client
 - make use of the keep-alive capabilities of LWP::UserAgent
   => one subprocess should accept a predefined number of requests
      (or all of them until it dies)
 - better handling of broken connection (from the client)

* other protocols
 - support for ftp
 - support for gopher 
   gopher://gopher.tc.umn.edu/
   gopher://marvel.loc.gov/

* special headers
 - support for hop by hop headers :
   => Connection, Keep-Alive, Proxy-Authenticate, Proxy-Authorization, TE,
      Trailers, Transfer-Encoding, Upgrade
 - handle big requests (see HTTP::Daemon::get_request documentation)

Better left to other modules
 - Browsing recording in a tree-like structure (thanks to Referer:)
   => maybe that should be left to a WWW::Mechanize::Builder module
 - become a POE component (OK, maybe that's another project)
   => POE::Component::?::?


Useful documentation:

http://www.stonehenge.com/merlyn/WebTechniques/col11.html
http://www.foad.org/~abigail/Perl/proxy.pl
http://rgarciasuarez.free.fr/perl/biscuit
http://www.jmarshall.com/tools/cgiproxy/

